README
Evapotranspiration (ET) Analysis and Processing in the East Central Texas Forests Ecoregion
Author: [Your Name]
Table of Contents

    Introduction
    Prerequisites
    Setup and Usage Instructions
    Code Overview
        Section 1: Cloud Statistics
        Section 2: Processing
        Section 3: Filter Out Extreme Values
        Section 4: Calculate Average of Rasters
    Output Details
    Notes and Considerations
    Troubleshooting
    Contact Information

Introduction

This script is designed to perform comprehensive analyses of Evapotranspiration (ET) data within the East Central Texas forests ecoregion using Google Earth Engine (GEE). The script includes:

    Cloud Statistics: Computing cloud-free observation counts from multiple ET models.
    Processing: Applying cloud-free masks, removing outliers, calculating median ET values, and comparing model outputs.
    Filtering Out Extreme Values: Excluding extreme ET values beyond a certain threshold in a raster image.
    Calculating Average of Rasters: Computing the average ET from five different raster images.

The script leverages data from the OpenET project and other GEE datasets to provide detailed ET analyses for research and resource management purposes.
Prerequisites

Before running the script, ensure you have:

    Google Earth Engine Account:
        Sign up at Google Earth Engine.
    Access to Necessary Datasets:
        OpenET datasets are publicly available.
        Access to any custom assets referenced in the script (e.g., 'users/horia/Sebal_POS_2016').
    Familiarity with GEE Code Editor:
        Basic understanding of JavaScript and GEE scripting is helpful.

Setup and Usage Instructions
Step 1: Access Google Earth Engine Code Editor

    Open the GEE Code Editor.

Step 2: Copy the Script

   ////
////                       CLOUD STATISTICS
////


// Step 1: Define the Area of Interest (AOI) - East Central Texas Forests Ecoregion
var ecoregions = ee.FeatureCollection("RESOLVE/ECOREGIONS/2017");
var aoi = ecoregions.filter(ee.Filter.eq('ECO_NAME', 'East Central Texas forests'));

// Step 2: Load the 5 ET collections and sum the monthly values to get cloud-free count band for December 2022 to December 2023

// Function to extract the 'count' band from each model
function getCloudFreeCount(imageCollection, aoi) {
  return imageCollection
          .filterBounds(aoi)
          .filterDate('2013-01-01', '2013-12-31')
          .select('count')  // Select the count band
          .sum()  // Sum across the year to get total cloud-free count
          .clip(aoi);  // Clip to AOI
}

// EEMETRIC Count Band
var eemetricCount = getCloudFreeCount(ee.ImageCollection("OpenET/EEMETRIC/CONUS/GRIDMET/MONTHLY/v2_0"), aoi);

// PTJPL Count Band
var ptjplCount = getCloudFreeCount(ee.ImageCollection("OpenET/PTJPL/CONUS/GRIDMET/MONTHLY/v2_0"), aoi);

// DISALEXI Count Band
var disalexiCount = getCloudFreeCount(ee.ImageCollection("OpenET/DISALEXI/CONUS/GRIDMET/MONTHLY/v2_0"), aoi);

// SSEBOP Count Band
var ssebopCount = getCloudFreeCount(ee.ImageCollection("OpenET/SSEBOP/CONUS/GRIDMET/MONTHLY/v2_0"), aoi);

// GEESEBAL Count Band
var geesebalCount = getCloudFreeCount(ee.ImageCollection("OpenET/GEESEBAL/CONUS/GRIDMET/MONTHLY/v2_0"), aoi);

// Step 3: Compute summary statistics (min, max, mean, stdDev) for each cloud-free count band

// Function to compute statistics for a count band
function computeStatistics(image, name) {
  var stats = image.reduceRegion({
    reducer: ee.Reducer.min().combine(ee.Reducer.max(), '', true)
                         .combine(ee.Reducer.mean(), '', true)
                         .combine(ee.Reducer.stdDev(), '', true),
    geometry: aoi.geometry(),
    scale: 30,  // Use a 30m resolution
    maxPixels: 1e13
  });
  
  print('Statistics for ' + name, stats);
}

// Compute and print statistics for each model
computeStatistics(eemetricCount, 'EEMETRIC');
computeStatistics(ptjplCount, 'PTJPL');
computeStatistics(disalexiCount, 'DISALEXI');
computeStatistics(ssebopCount, 'SSEBOP');
computeStatistics(geesebalCount, 'GEESEBAL');

////
//// Processing 
////



// Step 1: Define the Area of Interest (AOI) - East Central Texas Forests Ecoregion
var ecoregions = ee.FeatureCollection("RESOLVE/ECOREGIONS/2017");
var aoi = ecoregions.filter(ee.Filter.eq('ECO_NAME', 'East Central Texas forests'));

// Step 2: Define the cloud-free threshold
var cloudFreeThreshold = 17;

// Function to get the cloud-free count mask 
function getCloudFreeMask(imageCollection, aoi) {
  var countBand = imageCollection
                    .filterBounds(aoi)
                    .filterDate('2022-01-01', '2022-12-31')
                    .select('count')  // Select the count band
                    .sum()  // Sum across the year to get total cloud-free count
                    .clip(aoi);
  
  // Create mask for pixels that have cloud-free counts greater than set threshold 
  return countBand.gte(cloudFreeThreshold);  // Mask where count >= threshold
}

// Function to apply cloud-free mask to ET image collection
function applyMaskToET(imageCollection, mask, aoi) {
  return imageCollection
           .filterBounds(aoi)
           .filterDate('2022-01-01', '2022-12-31')
           .sum()  // Sum the monthly ET values
           .select([0])  // Select the first band
           .updateMask(mask)  // Apply the cloud-free mask
           .clip(aoi);
}

// Step 3: Get cloud-free masks for each model
var eemetricMask = getCloudFreeMask(ee.ImageCollection("OpenET/EEMETRIC/CONUS/GRIDMET/MONTHLY/v2_0"), aoi);
var ptjplMask = getCloudFreeMask(ee.ImageCollection("OpenET/PTJPL/CONUS/GRIDMET/MONTHLY/v2_0"), aoi);
var disalexiMask = getCloudFreeMask(ee.ImageCollection("OpenET/DISALEXI/CONUS/GRIDMET/MONTHLY/v2_0"), aoi);
var ssebopMask = getCloudFreeMask(ee.ImageCollection("OpenET/SSEBOP/CONUS/GRIDMET/MONTHLY/v2_0"), aoi);
var geesebalMask = getCloudFreeMask(ee.ImageCollection("OpenET/GEESEBAL/CONUS/GRIDMET/MONTHLY/v2_0"), aoi);

// Step 4: Combine the cloud-free masks from the 5 models
var combinedMask = eemetricMask.and(ptjplMask)
                               .and(disalexiMask)
                               .and(ssebopMask)
                               .and(geesebalMask);

// Step 5: Apply the combined cloud-free mask to ET data for each model
var eemetricET = applyMaskToET(ee.ImageCollection("OpenET/EEMETRIC/CONUS/GRIDMET/MONTHLY/v2_0"), combinedMask, aoi);
var ptjplET = applyMaskToET(ee.ImageCollection("OpenET/PTJPL/CONUS/GRIDMET/MONTHLY/v2_0"), combinedMask, aoi);
var disalexiET = applyMaskToET(ee.ImageCollection("OpenET/DISALEXI/CONUS/GRIDMET/MONTHLY/v2_0"), combinedMask, aoi);
var ssebopET = applyMaskToET(ee.ImageCollection("OpenET/SSEBOP/CONUS/GRIDMET/MONTHLY/v2_0"), combinedMask, aoi);
var geesebalET = applyMaskToET(ee.ImageCollection("OpenET/GEESEBAL/CONUS/GRIDMET/MONTHLY/v2_0"), combinedMask, aoi);

// Step 6: Stack the 5 ET images into a single multi-band image
var etStack = eemetricET.addBands(ptjplET)
                        .addBands(disalexiET)
                        .addBands(ssebopET)
                        .addBands(geesebalET);

// Step 7: Calculate the median for each pixel across the 5 models
var etMedian = etStack.reduce(ee.Reducer.median());

// Step 8: Calculate the absolute deviation of each model's ET from the median
var etAbsoluteDeviation = etStack.subtract(etMedian).abs();

// Step 9: Calculate the Median Absolute Deviation (MAD) for each pixel
var etMAD = etAbsoluteDeviation.reduce(ee.Reducer.median());

// Step 10: Define the threshold for outliers (1.2 times the MAD)
var madThreshold = etMAD.multiply(1.2);

// Step 11: Create masks for each band where the deviation is within the threshold
function maskOutliers(image, median, madThreshold) {
  var deviation = image.subtract(median).abs();
  return image.updateMask(deviation.lte(madThreshold));  // Mask pixels with deviation > threshold
}

// Apply the outlier mask to each ET model
var eemetricFiltered = maskOutliers(eemetricET, etMedian, madThreshold);
var ptjplFiltered = maskOutliers(ptjplET, etMedian, madThreshold);
var disalexiFiltered = maskOutliers(disalexiET, etMedian, madThreshold);
var ssebopFiltered = maskOutliers(ssebopET, etMedian, madThreshold);
var geesebalFiltered = maskOutliers(geesebalET, etMedian, madThreshold);

// Step 12: Sum the filtered ET values for all models
var etSumFiltered = eemetricFiltered.add(ptjplFiltered)
                                    .add(disalexiFiltered)
                                    .add(ssebopFiltered)
                                    .add(geesebalFiltered);

// Step 13: Count the number of valid (unmasked) models for each pixel
var validCount = eemetricFiltered.unmask(0).gt(0)
                .add(ptjplFiltered.unmask(0).gt(0))
                .add(disalexiFiltered.unmask(0).gt(0))
                .add(ssebopFiltered.unmask(0).gt(0))
                .add(geesebalFiltered.unmask(0).gt(0));

// Step 14: Calculate the mean ET, considering only unmasked values
var etMeanFiltered = etSumFiltered.divide(validCount);


// Step 15: Load the OpenET Ensemble collection and sum the monthly values for 2023, applying the same combined mask
var ensembleET = ee.ImageCollection("OpenET/ENSEMBLE/CONUS/GRIDMET/MONTHLY/v2_0")
                  .filterBounds(aoi)
                  .filterDate('2023-01-01', '2023-12-31')
                  .sum()  // Sum the monthly ET values to get the annual value
                  .select([0])  // Select the first band
                  .updateMask(combinedMask)  // Apply the same cloud-free mask
                  .clip(aoi);

// Step 16: Compare the two datasets (difference between average of the 5 models and the Ensemble)
var etDifference = etMeanFiltered.subtract(ensembleET);

// Step 17: Visualization parameters for ET and difference
var etVisParams = {
  min: 300,
  max: 1700,  // Set appropriate range based on expected ET values
  palette: ['red', 'orange', 'yellow', 'green', 'blue']  // Color ramp for ET values
};

var diffVisParams = {
  min: -200,  // Set appropriate min/max based on expected differences
  max: 200,
  palette: ['red', 'white', 'blue']  // Red for negative, blue for positive differences
};

//Convert to double

eemetricFiltered = eemetricFiltered.toDouble();
ptjplFiltered = ptjplFiltered.toDouble();
disalexiFiltered = disalexiFiltered.toDouble();
ssebopFiltered = ssebopFiltered.toDouble();
geesebalFiltered = geesebalFiltered.toDouble();
//ensembleET = ensembleET.toDouble();

// Step 18: Visualize the annual ET and comparison


Map.addLayer(eemetricFiltered, etVisParams, 'EEMETRIC ET (Outliers Removed)');
Map.addLayer(ptjplFiltered, etVisParams, 'PTJPL ET (Outliers Removed)');
Map.addLayer(disalexiFiltered, etVisParams, 'DISALEXI ET (Outliers Removed)');
Map.addLayer(ssebopFiltered, etVisParams, 'SSEBOP ET (Outliers Removed)');
Map.addLayer(geesebalFiltered, etVisParams, 'GEESEBAL ET (Outliers Removed)');


// Visualize the mean ET after removing outliers and accounting for unmasked values
Map.addLayer(etMeanFiltered, etVisParams, 'Mean ET (Outliers Removed, Valid Models Only)');


// Visualize the OpenET Ensemble ET
Map.addLayer(ensembleET, etVisParams, 'OpenET Ensemble ET (2023, Cloud-Free Mask)');

// Visualize the ET difference (optional)
//Map.addLayer(etDifference, diffVisParams, 'Difference (Mean without Outliers - Ensemble) 2023');


// Step 19: Export the rasters to Google Drive
Export.image.toDrive({
  image: etDifference,
  description: 'etDifference',
  folder: 'Post Oak Savannah ET Project',
  fileNamePrefix: 'etDifference',
  region: aoi.geometry().bounds(),
  scale: 30,  // Set a suitable scale (30m is typical)
  crs: 'EPSG:3857',  // Set CRS to WGS84
  maxPixels: 1e13  // Allow a high number of pixels
});

Export.image.toDrive({
  image: eemetricFiltered,
  description: 'eemetricFiltered',
  folder: 'Post Oak Savannah ET Project',
  fileNamePrefix: 'eemetricFiltered',
  region: aoi.geometry().bounds(),
  scale: 30,  // Set a suitable scale (30m is typical)
  crs: 'EPSG:3857',  // Set CRS to WGS84
  maxPixels: 1e13  // Allow a high number of pixels
});

Export.image.toDrive({
  image: ptjplFiltered,
  description: 'ptjplFiltered',
  folder: 'Post Oak Savannah ET Project',
  fileNamePrefix: 'ptjplFiltered',
  region: aoi.geometry().bounds(),
  scale: 30,  // Set a suitable scale (30m is typical)
  crs: 'EPSG:3857',  // Set CRS to WGS84
  maxPixels: 1e13  // Allow a high number of pixels
});

Export.image.toDrive({
  image: disalexiFiltered,
  description: 'disalexiFiltered',
  folder: 'Post Oak Savannah ET Project',
  fileNamePrefix: 'disalexiFiltered',
  region: aoi.geometry().bounds(),
  scale: 30,  // Set a suitable scale (30m is typical)
  crs: 'EPSG:3857',  // Set CRS to WGS84
  maxPixels: 1e13  // Allow a high number of pixels
});

Export.image.toDrive({
  image: ssebopFiltered,
  description: 'ssebopFiltered',
  folder: 'Post Oak Savannah ET Project',
  fileNamePrefix: 'ssebopFiltered',
  region: aoi.geometry().bounds(),
  scale: 30,  // Set a suitable scale (30m is typical)
  crs: 'EPSG:3857',  // Set CRS to WGS84
  maxPixels: 1e13  // Allow a high number of pixels
});

Export.image.toDrive({
  image: geesebalFiltered,
  description: 'geesebalFiltered',
  folder: 'Post Oak Savannah ET Project',
  fileNamePrefix: 'geesebalFiltered',
  region: aoi.geometry().bounds(),
  scale: 30,  // Set a suitable scale (30m is typical)
  crs: 'EPSG:3857',  // Set CRS to WGS84
  maxPixels: 1e13  // Allow a high number of pixels
});

Export.image.toDrive({
  image: ensembleET,
  description: 'ensembleET',
  folder: 'Post Oak Savannah ET Project',
  fileNamePrefix: 'ensembleET',
  region: aoi.geometry().bounds(),
  scale: 30,  // Set a suitable scale (30m is typical)
  crs: 'EPSG:3857',  // Set CRS to WGS84
  maxPixels: 1e13  // Allow a high number of pixels
});




////
//// Filter out extreme values
////



// Step 1: Load your raster image asset
var etImage = ee.Image('users/horia/Sebal_POS_2016');


// Step 2: Define the Area of Interest (AOI) - East Central Texas Forests Ecoregion
var ecoregions = ee.FeatureCollection("RESOLVE/ECOREGIONS/2017");
var aoi = ecoregions.filter(ee.Filter.eq('ECO_NAME', 'East Central Texas forests'));
Map.centerObject(aoi, 8);

// Step 3: Clip the ET image to the AOI
var etClipped = etImage.clip(aoi);

// Step 4: Calculate the median and standard deviation across the AOI
var etStats = etClipped.reduceRegion({
  reducer: ee.Reducer.median().combine({
    reducer2: ee.Reducer.stdDev(),
    sharedInputs: true
  }),
  geometry: aoi,
  scale: 30,
  maxPixels: 1e9
});

// Step 5: Extract the median and standard deviation values
var etMedian = ee.Number(ee.Algorithms.If(etStats.get('et_median'), ee.Number(etStats.get('et_median')), ee.Number(0)));
var etStdDev = ee.Number(ee.Algorithms.If(etStats.get('et_stdDev'), ee.Number(etStats.get('et_stdDev')), ee.Number(0)));

// Step 6: Calculate the upper and lower thresholds (median +/- 3 * stdDev)
var upperThreshold = etMedian.add(etStdDev.multiply(3.5));
var lowerThreshold = etMedian.subtract(etStdDev.multiply(3.5));

// Step 7: Mask values outside the thresholds (flagging outliers)
var etMasked = etClipped.updateMask(etClipped.gte(lowerThreshold).and(etClipped.lte(upperThreshold)));

// Step 8: Add the filtered ET image to the map
Map.addLayer(etMasked, {
  min: lowerThreshold.getInfo(),
  max: upperThreshold.getInfo(),
  palette: ['blue', 'white', 'green']
}, 'Filtered ET (3 StdDev)');

// Step 9: Compute statistics of the filtered raster
var filteredStats = etMasked.reduceRegion({
  reducer: ee.Reducer.min().combine({
    reducer2: ee.Reducer.max(),
    sharedInputs: true
  }).combine({
    reducer2: ee.Reducer.mean(),
    sharedInputs: true
  }).combine({
    reducer2: ee.Reducer.median(),
    sharedInputs: true
  }).combine({
    reducer2: ee.Reducer.stdDev(),
    sharedInputs: true
  }),
  geometry: aoi,
  scale: 30,
  maxPixels: 1e9
});

// Print the resultant statistics
print('Filtered ET Image Statistics:', filteredStats);

// Step 10: Export the masked ET image to Google Drive
Export.image.toDrive({
  image: etMasked,
  description: 'Filtered_ET_3StdDev_Export',
  folder: 'Post Oak Savannah ET Project',
  fileNamePrefix: 'Filtered_ET_3StdDev_EastCentralTexas',
  region: aoi.geometry().bounds(),
  scale: 30,
  maxPixels: 1e9,
  crs: 'EPSG:3857',
  fileFormat: 'GeoTIFF'
});

// Step 11: Convert the statistics dictionary into a FeatureCollection for export
var statsDict = ee.Feature(null, filteredStats);
var statsFeatureCollection = ee.FeatureCollection([statsDict]);




////
//// Get Average
////

// Define the Area of Interest (AOI)
var ecoregions = ee.FeatureCollection("RESOLVE/ECOREGIONS/2017");
var aoi = ecoregions.filter(ee.Filter.eq('ECO_NAME', 'East Central Texas forests'));
Map.centerObject(aoi, 8);

// Load your five raster images
var raster1 = ee.Image('projects/ee-horia/assets/DisAlexi_ET');
var raster2 = ee.Image('projects/ee-horia/assets/Metric_ET');
var raster3 = ee.Image('projects/ee-horia/assets/PTJP_ET');
var raster4 = ee.Image('projects/ee-horia/assets/Seebal_ET');
var raster5 = ee.Image('projects/ee-horia/assets/SSEBOP_ET');

// Create a list of images
var imageCollection = ee.ImageCollection([raster1, raster2, raster3, raster4, raster5]);

// Function to check if a pixel is valid (non-null)
function validPixels(image) {
  return image.mask().neq(0);  // This checks for non-null (valid) pixels
}

// Sum of the valid images
var sumOfValid = imageCollection.map(function(image) {
  return image.unmask(0);  // Replace NoData with 0 for summing
}).sum();

// Count of valid (non-null) images
var countValid = imageCollection.map(validPixels).sum();

// Calculate the mean, avoiding NoData
var average = sumOfValid.divide(countValid);

// Clip the result to the AOI
var averageClipped = average.clip(aoi);

// Mask out zero values by applying an updateMask
var averageClippedNoZeros = averageClipped.updateMask(averageClipped.neq(0));

// Set visualization parameters (adjust based on your raster values)
var visParams = {
  min: 247,
  max: 1880,  // Adjust this based on the range of your data
  palette: ['blue', 'white', 'green']  // Example palette
};

// Add the average image (clipped and with 0 values masked to null) to the map
Map.addLayer(averageClippedNoZeros, visParams, 'Average of Rasters with No Zeros');

// Export the average raster to Google Drive, with 0 values replaced by null
Export.image.toDrive({
  image: averageClippedNoZeros,
  description: 'Average',
  folder: 'Post Oak Savannah ET Project',  // Specify the folder in Google Drive
  fileNamePrefix: 'Average_Rasters_NoZeros_Clipped',
  scale: 30,  // Adjust scale as needed
  maxPixels: 1e12,
  region: aoi.geometry().bounds(),  // Clipping to AOI
  crs: 'EPSG:3857',  // Set CRS if needed, default is WGS84
  fileFormat: 'GeoTIFF'
});

Step 3: Verify Asset Accessibility

    Ensure all datasets and assets used in the script are accessible to your GEE account.
    Modify asset paths if necessary, especially for custom assets like 'users/horia/Sebal_POS_2016'.

Step 4: Adjust Parameters (Optional)

    Dates: Adjust date ranges in functions if analyzing different time periods.
    Thresholds: Modify cloudFreeThreshold, MAD multipliers, and other thresholds as needed.
    Visualization Parameters: Adjust etVisParams and diffVisParams to suit your data ranges.

Step 5: Run the Script

    Click the Run button (▶️) at the top of the Code Editor.
    Monitor outputs in the Console, Map, and Tasks tabs.

Step 6: Monitor and Manage Exports

    In the Tasks tab, start export tasks to save images to Google Drive.
    Ensure you have sufficient storage space in your Google Drive account.

Step 7: Download Results

    After export tasks complete, download the images from your Google Drive for further analysis.

Code Overview

The script is divided into four main sections:
Section 1: Cloud Statistics

Purpose:

    Calculate cloud-free observation counts for each ET model over the AOI for the year 2013.
    Compute summary statistics (min, max, mean, stdDev) for these counts.

Key Steps:

    Define AOI:
        Use RESOLVE Ecoregions dataset to select the East Central Texas forests ecoregion.
    Compute Cloud-Free Counts:
        For each ET model, sum the 'count' band over 2013 to get total cloud-free observations.
    Compute Statistics:
        Calculate min, max, mean, and standard deviation for the cloud-free counts.
        Print statistics to the console.

Datasets Used:

    OpenET model collections (EEMETRIC, PTJPL, DISALEXI, SSEBOP, GEESEBAL).

Section 2: Processing

Purpose:

    Process ET data for 2022 by applying cloud-free masks, removing outliers, and calculating median ET values.
    Compare the mean ET of filtered models with the OpenET Ensemble data for 2023.

Key Steps:

    Define AOI and Cloud-Free Threshold:
        Use the same ecoregion as AOI.
        Set a cloud-free observation threshold (e.g., 17).
    Generate Cloud-Free Masks:
        Create masks for pixels with sufficient cloud-free observations for each model.
    Apply Masks and Sum ET Data:
        Apply the combined cloud-free mask to each model's ET data for 2022.
        Sum monthly ET values to get annual ET.
    Remove Outliers:
        Calculate the median ET across models.
        Compute Median Absolute Deviation (MAD) and define outlier thresholds.
        Mask outliers in each model's ET data.
    Calculate Mean ET and Compare with Ensemble:
        Calculate the mean ET across filtered models.
        Load OpenET Ensemble data for 2023.
        Compute the difference between the mean ET and Ensemble ET.
    Visualize and Export Results:
        Add layers to the map for visualization.
        Export processed images to Google Drive.

Datasets Used:

    OpenET model collections and Ensemble data.
    RESOLVE Ecoregions dataset.

Section 3: Filter Out Extreme Values

Purpose:

    Filter a specific raster ET image by removing extreme values beyond 3.5 standard deviations from the median.

Key Steps:

    Load Raster Image and Define AOI:
        Load the ET raster image (e.g., 'users/horia/Sebal_POS_2016').
        Define the AOI using the ecoregion.
    Compute Statistics:
        Calculate the median and standard deviation of ET values within the AOI.
    Define Thresholds and Mask Outliers:
        Set upper and lower thresholds at 3.5 standard deviations from the median.
        Mask out ET values outside these thresholds.
    Visualize and Export:
        Add the filtered ET image to the map.
        Export the masked ET image to Google Drive.

Datasets Used:

    Custom ET raster image.
    RESOLVE Ecoregions dataset.

Section 4: Calculate Average of Rasters

Purpose:

    Compute the average ET from five raster images, considering only valid (non-null) pixels.

Key Steps:

    Load Raster Images and Define AOI:
        Load five ET raster images from different models.
        Define the AOI using the ecoregion.
    Process Images:
        Replace NoData values with zero for summing.
        Count valid pixels across images.
    Calculate Average ET:
        Sum the valid images and divide by the count of valid pixels.
    Mask Zeros and Clip to AOI:
        Mask out zero values in the average image.
        Clip the result to the AOI.
    Visualize and Export:
        Add the average image to the map.
        Export the average raster to Google Drive.

Datasets Used:

    Five ET raster images (e.g., DisAlexi, Metric, PTJP, Seebal, SSEBOP).
    RESOLVE Ecoregions dataset.

Output Details

    Cloud Statistics:
        Console outputs of cloud-free observation statistics for each model.
    Processed ET Images:
        Filtered ET images with outliers removed for each model.
        Mean ET image after removing outliers.
        Difference image between mean ET and OpenET Ensemble ET.
    Filtered ET Image:
        Masked ET image with extreme values removed.
        Statistics of the filtered ET image printed to the console.
    Average ET Image:
        Average ET image computed from five raster images.
        Valid pixels only, zeros masked out.

Exported Files:

    Images exported to Google Drive in GeoTIFF format:
        etDifference.tif
        eemetricFiltered.tif
        ptjplFiltered.tif
        disalexiFiltered.tif
        ssebopFiltered.tif
        geesebalFiltered.tif
        ensembleET.tif
        Filtered_ET_3StdDev_EastCentralTexas.tif
        Average_Rasters_NoZeros_Clipped.tif

Notes and Considerations

    Data Accessibility:
        Ensure you have access to all datasets and assets referenced in the script.
        Modify asset paths if using different datasets or custom assets.
    Threshold Adjustments:
        The cloudFreeThreshold and MAD multiplier (1.2) are set based on assumptions and may need adjustment.
    Computation Limits:
        Large-scale computations may hit GEE's limits.
        Adjust maxPixels or process smaller regions if necessary.
    Visualization Parameters:
        Adjust min, max, and palette in visualization parameters to suit your data ranges.
    Export Settings:
        Ensure the folder parameter in Export.image.toDrive() matches an existing folder in your Google Drive or will be created.
    Time Frames:
        The script uses specific years for data processing. Adjust filterDate parameters as needed.

Troubleshooting

    Asset Not Found Errors:
        Verify that all asset paths are correct and that you have access to them.
    Computation Timeouts:
        If processing takes too long or fails, try reducing the AOI size or the date range.
    Null or Missing Data:
        Check for null values in your datasets. Use .unmask() or adjust masking as needed.
    Visualization Issues:
        If images do not display correctly, adjust the visualization parameters.
    Export Failures:
        Ensure you have enough storage in Google Drive.
        Check that maxPixels is set sufficiently high.

Contact Information

If you have any questions or need assistance, please contact:

    Name: Horia Olariu
    Email: horia@tamu.edu
    Affiliation: Texas A&M University - ECCB

Disclaimer: This script and documentation are provided "as is" without warranty of any kind. Use at your own risk. Ensure compliance with all data usage policies and licenses.

End of README
